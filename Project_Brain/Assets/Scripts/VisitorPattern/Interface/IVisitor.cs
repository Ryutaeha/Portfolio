
#region Advantages
// 장점
// - 새로운 연산을 쉽게 추가할 수 있습니다. 각기 다른 연산을 Visitor 클래스로 분리하여 추가할 수 있어 기존 구조를 변경하지 않고 기능을 확장할 수 있습니다.
// - 데이터 구조와 연산을 분리하여 코드의 응집도를 높입니다. 데이터 구조와 이를 처리하는 연산을 분리함으로써 각 클래스의 단일 책임 원칙을 준수할 수 있습니다.
// - 다양한 타입의 객체에 대해 동일한 연산을 수행할 수 있습니다. 방문자 패턴을 사용하면 객체의 타입에 상관없이 동일한 연산을 일관되게 적용할 수 있습니다.
// - 객체 구조를 변경하지 않고도 새로운 기능을 추가할 수 있습니다. 기존 객체 구조를 수정하지 않고 방문자 클래스를 추가하여 새로운 기능을 구현할 수 있습니다.
// - 유지보수성이 향상됩니다. 연산이 Visitor 클래스로 분리되어 있어 각 연산을 독립적으로 관리하고 수정할 수 있습니다.
#endregion

#region Disadvantages
// 단점
// - 객체 구조가 자주 변경될 경우 적합하지 않습니다. 객체 구조가 변경되면 모든 Visitor 클래스를 수정해야 하므로 유지보수가 어려워질 수 있습니다.
// - 객체 구조와 Visitor 간의 강한 결합이 발생할 수 있습니다. Visitor 패턴을 사용하면 객체 구조와 Visitor 클래스 간의 의존성이 높아질 수 있습니다.
// - 복잡성이 증가할 수 있습니다. 방문자 패턴을 잘못 사용하면 코드가 복잡해지고 가독성이 떨어질 수 있습니다.
// - 각 요소 클래스에 Accept 메서드를 추가해야 합니다. 모든 요소 클래스에 Accept 메서드를 구현해야 하므로 코드가 번거로워질 수 있습니다.
// - 새로운 요소 클래스를 추가할 때 모든 Visitor 클래스를 수정해야 합니다. 새로운 요소 클래스가 추가되면 모든 Visitor 클래스에 해당 클래스를 처리하는 메서드를 추가해야 합니다.
#endregion

#region When to Use
// 방문자 패턴을 사용할만한 경우
// - 객체 구조는 안정적이고, 새로운 연산이 자주 추가되는 경우: 객체 구조는 변하지 않지만, 새로운 연산이 자주 필요할 때.
// - 다양한 연산을 객체 구조에 적용해야 하는 경우: 여러 가지 연산을 동일한 객체 구조에 적용해야 할 때.
// - 데이터 구조와 연산을 분리하고 싶은 경우: 데이터 구조와 이를 처리하는 연산을 분리하여 코드의 응집도를 높이고 싶을 때.
// - 동일한 연산을 여러 객체 타입에 적용해야 하는 경우: 다양한 객체 타입에 대해 동일한 연산을 일관되게 수행해야 할 때.
// - 객체 구조를 변경하지 않고 새로운 기능을 추가하고 싶은 경우: 기존 객체 구조를 수정하지 않고 새로운 기능을 쉽게 추가하고자 할 때.
#endregion


// 방문자 패턴을 사용하여 CharacterShield 객체에 대한 특정 동작을 수행할 수 있습니다.
public interface IVisitor
{
    #region Methods
    // 이 메서드는 CharacterShield 객체를 방문할 때 호출됩니다.
    public void Visit(CharacterShield characterShield);

    // 이 메서드는 CharacterSpeed 객체를 방문할 때 호출됩니다.
    public void Visit(CharacterSpeed characterSpeed);

    // 이 메서드는 CharacterWeapon 객체를 방문할 때 호출됩니다.
    public void Visit(CharacterWeapon characterWeapon);
    #endregion
}
