using UnityEngine;

#region Advantages
// 장점
// - 변경 통지: 주체 객체(Subject)의 상태가 변경될 때, 이를 자동으로 모든 옵저버들에게 통지할 수 있습니다.
// - 느슨한 결합: 주체와 옵저버 간의 결합도가 낮아지므로, 시스템의 유연성과 확장성이 높아집니다.
// - 재사용성: 옵저버 객체들은 독립적으로 설계되어 재사용이 용이합니다.
// - 모듈성: 시스템을 모듈화하여 각 모듈이 독립적으로 동작할 수 있도록 합니다.
#endregion

#region Disadvantages
// 단점
// - 복잡성 증가: 옵저버가 많아질수록 시스템의 복잡성이 증가할 수 있습니다.
// - 성능 저하: 주체가 상태 변경을 통지할 때 모든 옵저버에게 알림을 보내므로 성능이 저하될 수 있습니다.
// - 순환 참조: 잘못된 구현으로 인해 주체와 옵저버 간의 순환 참조가 발생할 수 있습니다.
// - 예측 불가: 옵저버들이 주체의 상태 변경에 어떻게 반응할지 예측하기 어려울 수 있습니다.
#endregion

#region When to Use
// 옵저버 패턴을 사용할 만한 경우
// - 이벤트 처리 시스템: GUI 이벤트 핸들링, 게임 이벤트 시스템 등에서 이벤트를 처리할 때.
// - 모델-뷰-컨트롤러(MVC) 아키텍처: 모델의 상태가 변경될 때 뷰와 컨트롤러에 이를 통지할 때.
// - 분산 시스템: 여러 시스템 간에 상태를 동기화해야 할 때.
// - 실시간 데이터 피드: 주식 시세, 뉴스 피드 등 실시간 데이터를 여러 클라이언트에게 전달할 때.
// - 알림 시스템: 상태 변경에 따라 여러 모듈에 알림을 보내야 할 때.
#endregion

public abstract class Observer : MonoBehaviour
{
    #region Abstract Methods
    // Subject로부터 알림을 받았을 때 호출되는 추상 메서드입니다.
    // 각 Observer는 이 메서드를 구현하여 구체적인 알림 처리 로직을 작성해야 합니다.
    // 매개변수 subject는 알림을 보낸 Subject 객체입니다.
    public abstract void Notify(Subject subject);
    #endregion
}
